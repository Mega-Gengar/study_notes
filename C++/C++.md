

# 内联函数

```c++
inline void print(char *s)
{
    printf("%s", s);
}
```

- 宏没有类型检查，无论对还是错都是直接替换；而内联函数在编译时进行安全检查；
- 宏是预处理指令，在预处理的时候把所有的宏名用宏体来替换；内联函数是函数，在编译阶段把所有调用内联函数的地方把内联函数插入；

# 空类默认有哪些函数

1. 默认构造函数
2. 拷贝构造函数
3. 移动构造函数
4. 拷贝赋值运算符(取址运算符)
5. 移动赋值运算符(const 取址运算符)
6. 析构函数

# 枚举enum

枚举数据类型是一种由程序员定义的数据类型，其合法值是与它们关联的一组命名整数常量。

```c++
enum GameState {
    GAME_ACTIVE,
    GAME_MENU,
    GAME_WIN
}; 
```

# return *this

在成员函数中返回当前对象的引用。使得我们能够连续调用 printValue() 函数来输出设置后的值。

```c++
class MyClass {
public:
    MyClass& setValue(int value) {
        this->value = value;
        return *this;
    }
    
    void printValue() const {
        std::cout << "Value: " << value << std::endl;
    }
    
private:
    int value;
};
int main() {
    MyClass obj;
    obj.setValue(10).printValue();  // 使用链式调用设置值并打印
    
    return 0;
}
```



# static用法

[知乎来源](https://zhuanlan.zhihu.com/p/436392954)

### c中

1. 静态局部变量

   （1）该变量在全局数据区分配内存(局部变量在栈区分配内存);
   （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);
   （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);
   （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);

2. 静态全局变量

   静态全局变量不能被其它文件所用(全局变量可以);
   其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);

3. 静态函数

   静态函数不能被其它文件所用;
   其它文件中可以定义相同名字的函数，不会发生冲突

### c++中

1. 静态数据成员

   对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义

2. 静态成员函数

   静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态。

# const用法

1. const常量：在定义时必须初始化，之后无法更改
2. const成员变量：必须通过构造函数初始化列表初始化。
3. const成员函数：const对象只能调用const成员函数，非const对象都能调用。

# const放在成员函数后面

用const对成员函数进行声明，表示这个函数不会修改类中的任何数据成员。