# 兵棋态势推演

**2024.04~**至今       中国科学院软件研究所（天基重点实验室）    C++开发工程师

**项目简介**：《冰棋推演》用于地图战略部署，兵棋态势推演。项目对标美国军事部署兵棋系统，现在处于第三期开发，已部署使用。前端ui界面用**Qt**实现,后端用主要用**C++**,2D通过**OpenGL**对点军标进行绘制逻辑和图形渲染，3D使用**OSG**。

**个人职责**：参与《冰棋推演》2D兵棋部分绘制渲染的开发以及维护。

**成果描述：**

1、使用**FreeType**库，为2D军标库设计开发出一套**文字库系统**；

2、开发新功能，如鼠标跟**随点军标绘制**，修复UI界面与后端的**对接错误**问题；

3、使用**信号槽**、**多线程**，大幅度减少了**UI**界面加载速度，由原来的2s，降低到100ms。

4、编写需求相关算法，如**自相交多边形填充算法**、**多级渐进纹理算法**、**抽稀算法**等；



1、对需要渲染的字符使用Freetype库去加载它的字形，将矢量的字形渲染位图，图数据会包含字符的灰度信息。然后上传数据为opengl纹理，将每个文字渲染到屏幕合适的位置。freetype本身就能够解析多种字体，只要字体样式包含相应国家和地区的字符集，都能够解析并渲染。

字体旋转的实现：通过修改模型视图矩阵来实现的。先将字符以中心进行旋转，旋转完再平移回去，最后渲染字符。

粗体样式的实现：通过freetype库去则增加字形轮廓厚度，这种字形描边的办法来模拟粗体效果。

实现的功能有：字体旋转、字体样式的选择替换、字体大小控制、粗体样式、斜体样式、下划线、删除线等

2、

（1）难点在于要梳理清楚项目整体逻辑，鼠标点击事件的判断，点军标类根据时间生成唯一ID,存入军标容器里面，右击、以及替换军标则删除军标ID。

（2）对接错误包括一些军标生成的算法错误、军标填充消失、填充闪烁、填充图案跑到线性容器下面等等。

3、

（1）针对项目启动绘制地图再绘制属性面板里面的军标数据，导致项目启动过慢的问题，使用信号和信号槽在启动时在另一个线程加载军标数据绘制。遇到的难题，传递过去的C++容器数据在QT上面无法检测到，接收不到信号，解决办法是将该容器自定义为Qt可检测类型；会收到传递信号两次，导致属性面板重复绘制，原因是未接收到信号重复触发信号。

4、

（1）自相交多边形算法：在线军标填充绘制时，opengl只能绘制凸多边形，对于自相交的凹多边形无法处理。将图案打散为三角形绘制，对点重新进行排序。

（2）多级渐进纹理算法：加载分辨率最高的原始纹理级别，然后逐级递减纹理分辨率来生成Mipmap级别，存储在纹理对象中。opengl会自动选择合适大小的纹理。

（3）抽稀算法：在绘制军标时，由于点数量过多导致使用opengl绘制虚线时，点和点之间间隔太紧密，绘制出来的图像虚线很少。将点和点之间的像素距离设置成一定值，选择性收纳满足这个距离点坐标。然后重新绘制。

# 毁灭砖块

2023.06~至今          个人项目：毁灭砖块          技术：C++、OpenGL、Windows、CMake、Git
介绍：2D类型游戏，防止小球掉落并击毁所有砖块通关。
1、实现了游戏内球体与砖块、墙面的检测碰撞
2、美化小球在运动过程中的运动轨迹，添加拖尾粒子特效。
3、为了增加游戏趣味性，添加小球在捡到道具后会撞击窗口的震动特效。

游戏框架理解：采用单一性原则，游戏模块来管理游戏代码，资源管理器专门用来处理加载shader和纹理路径得载入。游戏内的物体砖块为基类，后续添加物体在此基础上进行派生。

> （1）碰撞检测算法改进优化：原来的轴对齐碰撞箱，根据物体位置来判断是否发生碰撞检测，大致思路是判断两物体是否有重合部分，如果有则发生碰撞。但是假如我的物体是个圆形，如何判断他是否发生检测碰撞？解决办法就是找到球体距离方形物体最近的点P，再判断这点距离是否与圆心的距离大于半径。如何求P点？可以通过计算物体之间的矢量差值和方形物体的半边长范围，通过这个范围来限制矢量插值，最后最近点P就是物体中心坐标加上修正后的矢量插值。

**（1）碰撞检测**：先是基本碰撞检测，主要是使用GJK算法，对每一个帧遍历所有物体进行检测碰撞。后续有对空间数据结构进行优化，尤其是针对物体数量增多。这里用了包围体的办法，就是用四边形包裹复杂物体，先进行上面的简单的包围体碰撞检测，如果发生碰撞，再使用GJK进行详细的检测。之后更新物体的状态，比如位置修正、速度增加减少、反弹的方向等等。

还能优化的地方比如如果项目很大，可以将碰撞检测丢到多线程里面。

**（2）粒子特效实现思路：**实现类似于拖尾的特效，实则是众多微粒在一起沿着运动方向位移，设置一个粒子的结构体，里面包含他的位置、速度、颜色和生命，在构造的时候给他们赋值。指定一定总量的粒子，缩小十倍渲染绘制。每帧更新得时候，检测生命值为0的粒子的索引生成新的粒子，并且更新大于0的生命的值。

**（3）特效实现**：往游戏中添加道具成员，在拾取道具后触发特效的实现，包括撞击晃动、倒置画面、还有混沌效果。撞击晃动实现通过触发修改顶点着色器的位置使他发生一个微小的变化，在片段着色器实现模糊效果。导致画面直接颠倒顶点着色器的x,y坐标值，然后在片段着色器纹理颜色翻转。混沌效果的实现是基于顶点着色器位置随着时间变化，呈现出画面左右随时间位移，顶点着色器纹理和边缘卷积核乘积呈现出一种混沌画风，增加游戏趣味性。

# 基于opengl的实时渲染器

介绍：项目基于开源项目LearnOpengl,使用stb_image库读取图像数据、Assimp库来读取模型数据，实现大部分常见的实时渲染算法。
1、实现了摄像机系统，熟悉LookAt矩阵实现细节并自定义,利用欧拉角控制视角旋转等。
2、编写并测试部分常见Shader，利用Blin-Phong光照模型实现模型的基础光照效果，利用模板测试技巧实现模型的描边效果，利用几何着色器可视化模型法线，利用帧缓冲实现画面后处理效果等。
3、实现了部分高级光照效果，包括基于ShadowMap的硬阴影，基于PFC、PCSS的软阴影的实时阴影效果，基于法线贴图以及视差贴图的低精度模型高表面细节效果，基于屏幕空间的环境光遮蔽效果

（**1）lookat矩阵**求取运用了三个向量值，我们需要的就是提供一个摄像机位置、目标位置、和世界坐标中向上的一个向量。在我设计的这个摄像机系统里面，将俯仰角和偏航角设置了一定范围，主要是为了避免运用欧拉角存在问题。万象节死锁问题，也就是说如果万向节的两个轴运动到平行的时候，就会失去一个自由度，然后就退化为二维空间中旋转。当然设计这个摄像机旋转还可以用四元数来做，存储了一个旋转轴和旋转的角度，但是他的具体实现原理没太懂。一般在实际运用中，程序里面用四元数，然后需要和用户交互的地方用欧拉角。

**（2）光照**有环境光照、漫反射光照，镜面反射。**重点是漫反射**，它的位置是在世界空间中计算的，顶点位置转换到世界坐标，通过法线向量和光源坐标和顶点的差值坐标去计算它们之间的夹角来乘以光的颜色。此外法线向量也得换算到世界空间位置来，取他逆矩阵的转置就好了。环境光光照就比较简单，设置好光照以后，在片段着色器里面直接将颜色乘以一个小的环境因子来表示环境光照的效果。镜面光照就是高光效果，也就是镜面光照最强的地方。

**模板测试**实现的物体描边，就是在绘制箱子的时候将模板函数设置为always，会将模板缓冲都更新为1。然后禁用模板的写入。将箱子物体放大一些，然后单独绘制深度缓冲模板值不为1的，输出一个颜色。最后呈现出来的效果就是箱子的描边效果，就和很多游戏里面那和选中物体和一些枪战游戏里面队友的描边效果类似。

**法线向量可视化，**他是运用几何着色器实现的。首先将定点着色器里面的法线变换到观察空间，几何着色器接受到以后，他能够在每个位置向量的地方绘制一个法向量。这个办法可以用来处理一些难以确定的光照效果，大部分都是法向量导致的，因此这个办法能够来查找法向量是否正确绘制。

**帧缓冲**可以用来让我们自己定义想要的颜色缓冲、深度缓冲、模板缓冲。他的实现先创建一个帧缓冲对象，然后创建一个颜色附件（例如纹理）,将颜色附件绑定到帧缓冲，然后是深度缓冲和模板缓冲，你也要绑定上去，有两种方式。一种是同样是通过纹理，将深度缓冲和模板缓冲存放到这个纹理上面，另一种是通过渲染缓冲对象附件的方式，这种方式会有一定优化，如果你不需要从缓冲上面进行采样的话。然后将它附件绑定到帧缓冲对象。最后绘制屏幕四边形，将之前的场景当作一个纹理绑定进去，这块就是后处理的核心，此时绘制这个四边形的时候我们不需要开启深度测试。然后是一些**后期处理的效果**，例如**反相效果**的实现就是在片段着色器里面用1-屏幕纹理里面的颜色值。**灰度图像**就是让场景只呈现出黑白灰，他的实现就是在片段着色器里面将所有颜色分量，也就是rpg平均化。**核效果**比如使用一个3x3的卷积核，周围都是1，只有中间是-9，他在片段着色器里面呈现出来的效果就是一个经过**锐化**后的图像，有点类似于风化的岩石和箱子、打麻药以后呈现出来的效果图。还有**模糊效果**也可以通过核来实现，区别就是卷积核里面的数值不同，它可以实现玩家喝醉酒的视觉效果、还有没戴眼镜等等，像黑神话里面天命人睁开眼睛的时候，也是用这个实现的。

（3）**硬阴影**：就是最简单的阴影类型在渲染时不会产生任何渐变或模糊效果，边缘非常清晰。它的实现先渲染深度贴图，记录物体到光到物体表面的距离，然后在摄像机视角下，对每个像素进行阴影计算，他会比较像素到光源的距离和存储在深度贴图中的深度值，
假如那个像素深度值大于深度贴图中的值，就说明该像素被遮挡，处于阴影区域。他的开销比较小，比较适合移动设备和低端设备。

​	**软阴影**效果有PFC和PCSS两种，他们主要就是改善硬阴影的不足，例如FPC他是对深度贴图进行多次采样来模糊阴影边缘的效果实现软阴影，当然他也有自己的缺点，就是他不会跟随物体和光源之间的距离变化来变化。然后PCSS就是在模糊边沿的基础上，能够动态的调整模糊程度。他的原理就是根据光源的大小和物体与光源的位置，计算遮挡的半径。遮挡物越靠近光源，阴影越清晰，遮挡物离光源越远，阴影越柔和。

**法线贴图**：他是用来模拟模型表面的凹凸和细节，他存储每个像素的法向量，来影响光照计算，从而产生更丰富的表面细节。

**视差贴图**：模拟表面深度信息的，他和法线贴图结合一起能够使表面细节和深度更有立体感。

一般像角色的皮肤、皱纹、衣物、建筑表面的凹凸细节，都可以用法线贴图和视差贴图实现。

**环境光遮蔽SSOA**：通过全局光照来增加阴影效果，提高场景的立体感，尤其是物体接缝处和凹陷处的光照遮蔽。主要的步骤是在屏幕空间像素周围采样多个位置，使用法线图、深度图计算采样点的遮蔽程度，用遮蔽效果来增强阴影区域使细节突出。