# OpenGL

[来源](https://blog.csdn.net/weixin_44478077/article/details/123977641)

1. **什么是渲染管线？具体流程是什么？**

   它是将数据经过一步步操作最终输出到屏幕的过程。

   将顶点数据输入到顶点着色器，他会对顶点的属性进行基本的处理，然后进行几何着色器，他会将顶点数据转换成基本图元。接着在图元装配中将所有的点装配成指定图元的形状。然后进行光栅化，将基本图元映射到屏幕网格上的像素点。在片段着色器中对每个像素点计算最终颜色，例如光线、阴影等。最后再进行测试与混合，对每个像素点进行深度测试、模板测试、颜色混合操作，最终显示在屏幕上。

2. **有哪些坐标空间？都是如何相互转化的？**

   本地坐标系，世界坐标系，观察坐标系，裁剪空间、屏幕空间

   本地坐标系通过model矩阵转换为世界坐标系，通常可以进行平移、旋转、缩放

   世界坐标通过view矩阵转化为观察坐标，通常用来模拟摄像机视角

   观察坐标通过projection矩阵转化为裁剪空间，通常有正射投影矩阵以及透视投影矩阵。

   裁剪空间通过视口变化转变为屏幕空间，

3. **什么是视口变换？**

   就是将投影过后归一化的点映射到屏幕上指定区域，在OpenGL中通过glviewport实现的

4. **什么是顶点缓冲对象，VBO?**

   顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。

5. **什么是顶点数组对象，VAO？**

   每次在绘制模型前需要绑定顶点信息，数据量很大时，重复这样的动作会变得很麻烦。VAO可以把这些所有的配置都存储在一个对象上，绘制模型的时候只需要绑定这个VAO对象就可以了。

   VAO就是一个大的顶点属性的集合，它存储这VBO对象的引用。

6. **三个着色器有什么用？**

   顶点着色器：处理顶点数据。

   几何着色器：将基本图元造成新的基本图元生成其他形状

   片段着色器：计算光栅化的每一个像素点的最终颜色，包括光线、阴影等。

7. **opengl有哪些缓冲？分别的作用？**

   颜色缓冲：包含每个像素的颜色信息以及alpha值

   元素缓冲：缓存顶点序号数据

   顶点缓冲：缓存顶点数据信息

   深度缓冲：缓存像素点的深度信息，与z轴相关

   模板缓冲：包含物体的模板值

   帧缓冲：是渲染最终的结果，是其他渲染的结合

8. **帧缓冲**

   帧缓冲整体架构是：先创建一个帧缓冲对象，然后创建一个颜色附件（例如纹理）,将颜色附件绑定到帧缓冲，然后是深度缓冲和模板缓冲，你也要绑定上去，有两种方式。一种是同样是通过纹理，将深度缓冲和模板缓冲存放到这个纹理上面，另一种是通过渲染缓冲对象附件的方式，这种方式会有一定优化，如果你不需要从缓冲上面进行采样的话。然后将它附件绑定到帧缓冲对象。最后绘制屏幕四边形，将之前的场景当作一个纹理绑定进去，这块就是后处理的核心，此时绘制这个四边形的时候我们不需要开启深度测试。然后是一些后期处理的效果，挺好看的

9. **片段和像素的区别？**

   片段是指光栅化以后经过片段着色器最终的颜色集合，二像素是指片段经过混合、模板测试、深度测试以后的最终输出。

10. **什么是深度缓存算法？**

   每个像素点初期都有个无限远的深度值，当绘制一个片段的深度值比这个值大，则跳过该片段，当片段比当前值小则替换更新片段。

11. **光照计算处理有哪些部分？**

    环境光照：环境因子x物体颜色

    漫反射：法向量x定向光x物体颜色

    镜面反射：

12. **反走样原理，如何实现？**

    增加分辨率、先模糊后采样。增加采样点数。

13. **为什么有抗锯齿？如何消除？**

    有限的像素点去逼近连续的三角形，就会出现锯齿走样的现象。

    可以通过SSAA将每个像素点细分为4个采样点，但是计算量会大幅度增加。而MSAA在他的基础上，只会计算有几个采样点会背三角形覆盖。

14. **OpenGL渲染流水线怎样提高渲染效率？**

    减少使用Draw Call，优先使用VAO，使用背面剔除等。

15. **如何绘制半透明物体？**

    先绘制不透明物体，再对透明物体进行排序，最后按照顺序绘制透明物体。

16. **深度测试？**

    深度测试启用以后会将一个片段的深度值与深度缓冲中的内容进行对比，如果这个测试通过，则深度缓冲更新新的深度值，如果失败则丢弃该片段。

17. **提前深度测试**

    提前深度测试是在片段着色器之前，如果开启提前深度测试，那么片段着色器会写入一个限制，不能再写入深度值。它可以更早地丢掉一些片元，节省GPU资源。

18. **深度冲突如何处理？**

    深度缓冲就是两个平行的平面，没有足够的精度来确定谁在前谁在后。

    要解决这个问题，可以使用更高精度的深度缓冲，也可以沿着y轴稍微偏移一点，也可以将尽可能将近平面设置远一些

19. **模板测试？**

    片段着色器处理完以后，模板测试开始执行，模板测试又是根据模板缓冲的值来选择是否丢弃还是保留片段。

20. **顶点法线和面法线的作用？**

    面法线垂直于平面，位于中央，常用于flat着色

    顶点法线常用于冯光照模型的计算，确保每个顶点处的明暗和光滑。

21. **法线所在空间如何变换到世界空间**

    局部空间通过逆矩阵的转置来将法线转换到世界空间。

22. **大致说一下着色器工作的处理流程**

    1. 顶点着色程序的源代码和片段作色程序的源代码要分别保存到一个字符数组里面；
    2. 使用glCreateshader()分别创建一个顶点着色器对象和一个片段着色器对象；
    3. 使用glShaderSource()分别将顶点着色程序的源代码字符数组绑定到顶点着色器对象，将片段着色程序的源代码字符数组绑定到片段着色器对象；
    4. 使用glCompileShader()分别编译顶点着色器对象和片段着色器对象；
    5. 使用glCreaterProgram()创建一个（着色）程序对象；
    6. 使用glAttachShader()分别将顶点着色器对象和片段着色器对象附加到（着色）程序对象上；
    7. 使用glLinkProgram()对（着色）程序对象执行链接操作
    8. 使用glValidateProgram()对（着色）程序对象进行正确性验证
    9. 最后使用glUseProgram()将OpenGL渲染管道切换到着色器模式，并使用刚才做好的（着色）程序对象。

23. **[OpenGL中怎么传递变量](https://blog.csdn.net/wykxwyc/article/details/100007998?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-100007998-blog-123977641.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.4&utm_relevant_index=8)？**

    uniform变量：是外部application程序传给shader的变量

    attribute变量：vertex shader使用的变量，一般用来表示顶点数据。

    varying变量：是fragment以及vertex shader之间做数据传递的变量。

24. **CPU和GPU之间如何调度的**

    opengl主程序由CPU调度运行，图像处理部分通过GLSL交由GPU执行。

    1. 利用内置的OpenGL函数生成一个ID号码
    2. 对该ID号码进行内存类型的绑定
    3. 数据提交到GPU专用的内存中

25. **mipmap是什么**

    多级渐进纹理，一组分辨率逐渐降低的纹理序列组成，每一级纹理宽度和高度都是上一级纹理宽度和高度的一半。优点是提高渲染速度，减少锯齿，缺点是占显存。

26. **硬阴影**

    就是最简单的阴影类型在渲染时不会产生任何渐变或模糊效果，边缘非常清晰。它的实现先渲染深度贴图，记录物体到光到物体表面的距离，然后再通过计算片段是否在阴影中。缺点就是以阴影的光源非常模糊。

27. **阴影失真**

    阴影贴图受限于分辨率，在距离光源较远的情况下，多个片段可能会在深度贴图上面采集到同一个值。要解决这个问题可以用阴影偏移的方法，使用一个偏移量来获取合适的深度值。但是假如偏移量较大，可能会导致悬浮现象，看着像飘在上面。这个失真问题可以通过正面剔除来解决。

28. **软阴影pcf和PCSS**

    阴影产生锯齿是由于深度贴图有固定的分辨率，除了通过增加深度贴图的分辨率的方法，还有一个解决办法就是PCF，大概思路就是在深度贴图中多次采样，结合以后平均化来减少锯齿块以及柔化。pcss就是比pcf更高级的一种软阴影的算法，他是用来模拟现实中的面积光源，根据光源和遮挡物之间的距离动态的调整阴影模糊的程度。

29. **点光阴影**

    相比于定向阴影映射，只是将2D深度贴图变成立方体贴图。这就是区别。

30. **环境光遮蔽SSAO**

    增强场景细节和深度感的后期处理效果。它主要通过模拟光线在物体表面和物体之间的遮蔽来改善阴影的真实性，看起来更有深度和立体感。

31. **常见的draw call优化处理方法**

    批处理：将多个具有相同材质的物体合并成一个物体进行渲染

    实例化渲染：对于大量相同的物体一次性发出一个draw call渲染多个实例

    纹理图集：将多个小的纹理合并成一个大纹理减少纹理切换、从而降低draw call的数量。

32. **如何减少移动设备上的渲染开销？**

    降低draw calls

    降低分辨率，还可以使用动态分辨率来根据帧自动调整分辨率。

    简化shader：减少分支和条件判断、使用简单的光照模型、减少纹理采样

    减少过度绘制：也就是同一个像素被多次绘制，增加了GPU的负担。透明物体按照深度排序绘制，还有前向剔除，剔除视锥外的物体，不渲染不可见物体。

33. **URP和内置渲染管线**

    URP也叫通用渲染管线，相比于内置渲染管线适应移动设备和低端设备，主要是在Draw calls 和过度绘制方面有优化。URP默认使用前向渲染，能够减少不必要的光照计算，只计算受影响的光源，它还能够将渲染流程不必要的功能剥离开来。而内置渲染管线灵活性更高但是优化方面不如URP，但是它能够处理复杂的光源和阴影处理，更适合高端PC端。

34. **URP主要后期处理效果包括哪些？**

    抗锯齿：支持多重采样抗锯齿（MSAA）,而SMAA需要自行实现。

    景深：根据摄像机位置调整清晰度，使物体变模糊模拟摄像机的焦点效果。

    运动模糊：更具相机的移动速度增加模糊效果，增强物体快速移动市的动感和现实感，适合赛车游戏。

# c++

1. **在main执行之前和之后执行的代码可能是什么？**

   执行之前主要是初始化系统相关资源，例如栈指针、初始化静态变量以及全局变量、而将未初始化的变全局量赋初值、调用构造函数，然后是将main函数参数传递给main函数。执行之后会调用全局对象的析构函数。

2. **结构体内存对齐问题**

   结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同，一般按结构体中size最大的成员对齐

3. **指针和引用的区别**

   指针是一个变量存储的是一个地址，而引用就是一个别名。

   指针可以是多级的，而引用只有一级。

   指针可以为空，而引用刚开始必须初始化，而且指针可以改变指向，而引用初始化后不行。

4. **传递函数参数时什么时候用指针什么时候用引用？**

   返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。

   对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。

   类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。

5. **堆和栈的区别**

   堆是程序员自己申请和释放的，栈是系统自动分配

   效率上栈因为是系统分配，速度块不会有碎片，而堆是程序员分配，由函数库提供的，获取堆内容需要两次访问，一次访问指针一次访问内存，因此速度慢，且会有碎片。

6. **new / delete 与 malloc / free的异同**

   两者都是对内存的申请和释放的。但是前者是c++运算符，后者是c/c++标准库函数。new会自动计算需要的空间大小，而malloc需要手动计算。new调用名为**operator new**的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数，然后通过调用名为**operator delete**的标准库函数释放内存。malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能

7. **宏定义和函数有什么区别？**

   宏是在函数预处理阶段执行的直接参与文体替换之后参与编译，运行时不存在函数调用，执行的更快。而函数调用需要在运行时到具体调用函数。

   宏没有返回值，而函数有。

   宏定义无函数检查，而函数要进行类型检查。

8. **变量声明和定义区别？**

   声明是指告诉编译器变量声明的位置以及类型，但是并不分配空间。而定义要为其分配空间。

   相同的变量可以多处声明，但是只能在一处定义。

9. **strlen和sizeof区别？**

   sizeof是运算符，是在编译中得到结果，并非运行时。strlen是字符串处理的库函数。sizeof参数可以是任何数据类型，而strlen参数只能是字符指针。

10. **基本数据类型所占字节**

    |               | 16位编译器 | 32位 | 64位 |
    | :-----------: | :--------: | :--: | :--: |
    |  char和bool   |     1      |  1   |  1   |
    |     char*     |     2      |  4   |  8   |
    |   short int   |     2      |  2   |  2   |
    |    **int**    |     2      |  4   |  4   |
    |     float     |     4      |  4   |  4   |
    |    double     |     8      |  8   |  8   |
    |   **long**    |     4      |  8   |  8   |
    |   long long   |     8      |  8   |  8   |
    | unsigned long |     4      |  4   |  8   |

11. **常量指针和指针常量**

    常量指针指的是指针本身是常量，不可改变指针的指向，而指向的对象可以改变。星号在const左边。int * const p;

    指针常量指的是指针所指对象为常量，不可改变，但是指针本身能够改变指向。星号在const右边。int const *p;

12. **C++中struct和class的区别**

    相同点：两者都有成员函数、共有和私有。class能够做的struct也能。

    不同点：不指定类型struct默认为共有，class默认为私有。

13. **c++static**

    不在类中的情况：

    ​	对于不加static的**全局变量和函数**具有全局可见性，能够在其他文件中使用，加了以后只能够在该文件编译模块使用。

    ​	对于未初始化的static**全局变量和局部变量**默认初始化为0，且在全局未初始化区域。

    ​	static变量在函数内定义会始终存在，且只进行一次初始化，只能在函数范围内使用，离开函数依旧存在但是不能够使用。

    在类中的情况：

    ​	static成员变量：静态数据成员是属于类本身的，而不是属于类的任何特定对象的。不能在类的声明初始化，必须在类定义外初始化。

    ​	static成员函数：能够由类直接调用。不能访问类的非static成员和成员函数，能偶被非static成员函数任意访问。

14. **c++const**

    不考虑类的情况：

    ​	const常量在定义时必须初始化，之后无法更改。

    ​	const形参可以接受非const和const类型的实参

    考虑类的情况：

    ​	const成员变量：只能通过构造函数的初始化列表初始化。不能在类声明时初始化，因为不同实例化对象的const成员值可以不同。

    ​	const成员函数：const成员函数可以访问对象的所有数据成员，可以被非const和const对象都能调用。

15. **final和override关键字**

    override是子类对父类的虚函数进行重写时，如果函数名与父类不同就报错。

    final是指你不希望某个类被继承以及某个虚函数被重写，可以在类后面以及函数后面加final。

16. **野指针与悬空指针**

    野指针指的是指针变量未及时初始化，因此每次记得置空

    悬空指针指针free和delete后未及时置空。

17. **重载、重写和隐藏**

    重载：同名函数的参数类型和数目有所不同

    重写：子类重写父类方法，要求父类函数必须是虚函数。要求是与父类同名、参数类型、个数以及返回值类型都相同

    隐藏：派生类中的函数屏蔽了基类中的同名函数

18. **c++有哪些构造函数？**

    默认构造函数：不带参数的

    初始化构造函数：带参数和参数列表，两者都是为了完成对象初始化工作

    拷贝构造函数：拷贝类对象

    转换构造函数：将其他类型的变量转化为本类对象

19. **深拷贝和浅拷贝**

    浅拷贝：拷贝的只是一个指针，和原来指针指向同一片地址，如果原来的地址被释放了，在释放浅拷贝的指针所指地址就会发生错误。

    深拷贝：不仅会拷贝值，也会新开辟一块空间存放内容，当原来的指针所指的资源被释放后，也不会影响深拷贝的内容

20. **大端存储和小端存储**

    大端存储：高字节存在低地址

    小端存储：低字节存在低地址

    判断方法：使用强制类型转换，例如int类型强制转换为char类型，就只保留下低地址部分。

21. **什么情况下会调用拷贝构造函数？**

    用一个实例化类对象去初始化另一个类对象的时候

    函数参数是类对象的时候，非引用传递的

    函数返回值是函数体内的局部类对象，返回值是调用了拷贝构造函数。

22. **volatile、mutable、explicit关键字用法**

    volatile关键字是一种类型修饰符，他修饰的变量是易变的。每次都是直接读取他的内存里面的值，而不是从寄存器里面备份的读取。

    mutable关键字允许类的成员变量在常量上面修改

    explicit关键字防止类的构造函数在隐式转换中被调用。默认情况下	构造函数会在需要时被隐式转换，可能出现意外，使用explicit可以确保只有显示转换能够触发构造函数。

23. **直接初始化和拷贝初始化**

    直接初始化是直接调用相对应的构造函数，拷贝初始化是调用构造函数生成一个临时对象，再调用拷贝构造函数拷贝到对象上。

24. **静态变量什么时候初始化？**

    静态变量存储在静态数据区，在C语言中会在其代码执行之前初始化，也就是在编译阶段，在c++中由于对象的引入对象生成必须要调用构造函数。因此静态变量会在首次用到时才会进行构造。

25. **类成员初始化方式？为什么成员列表初始话方式会快一点？**

    类成员初始化方式有赋值初始化以及列表初始化，赋值初始化是在数据成员在分配空间以后进行的初始化，且会产生临时对象；列表初始化是在数据成员在分配空间时就初始化的，速度要快很多。

26. **封装、继承、多态**

    封装：把客观事屋封装成抽象类，并且类可以把自己的数据和方法只让可信任的类或者对象操作，对于不可信的进行信息隐藏。例如public、private。

    继承：让某个类型的对象获得另一个类型的对象属性和方法，它可以使用现有类的所有功能和方法，并且无需重新编写原来的类在它基础上对这些功能进行扩展。例如有一个人类型的抽象类，他有姓名、性别、等等这些公共的方法，在定义一个人的时候就能够继承这些属性和方法，还能够在此基础上进行扩充。

    多态：不同对象做同一件事表现出不同的结果。比如买票，成人买的是全价票，学生买的半价票。实现多态有两种方式，一种是重载，另一种覆盖（子类重新定义父类的虚函数的做法）。

27. **虚函数表**

    虚函数表是一个存放指向虚函数的指针数组。每一个有虚函数的类都有一个相关联的虚函数表。当调用一个对象的虚函数的时候编译器就会定位虚函数表，在到虚函数表里面找到相应的虚函数指针调用这个函数，因此可以实现多态。

28. **纯虚函数**

    在虚函数后面写上**=0**就叫纯虚函数，包含纯虚函数的类叫做抽象类也叫接口类。该类不能实例化对象，包括他的派生类，只有在派生类中重写纯虚函数才能够实例化出对象。这也体现了接口继承的一种方式。

29. **虚函数和纯虚函数区别**

    纯虚函数只有定义没有实现，而虚函数既有定义也有实现。

30. **构造函数能够是虚函数吗**

    不能。假如构造函数是虚函数，那就在虚函数表中，而虚函数表又要找虚函数表指针，而虚函数表指针又存在于对象中。而调用构造函数之后，才能生成对象。矛盾了。

    但是析构函数能够是虚函数，把基类析构函数定义为虚函数，则调用析构函数时会去虚函数表中找对应的虚函数，此时找到的是派生类的析构函数，之后会调用基类的析构函数，因此不会导致内存泄漏。

31. **移动构造函数**

    当用一个对象初始化另一个对象的时候，打算释放原来对象的空间，但是为啥不用新的对象直接指向这片空间，这样就避免了空间的分配降低了构造成本。这就是移动构造函数的思路。

32. **全局变量和局部变量的区别**

    全局变量随主程序创建而创建，随它销毁而销毁。而局部变量作用范围只在函数体内，出了函数体立即销毁。全局变量是放在全局存储区，而局部变量放在堆栈区。

33. **指针参数传递和引用参数传递**

    指针参数传递实则是对实参值的拷贝，形参和实参一样指向同一个值，但是对形参在函数范围内做的任何操作都不会影响实参。

    引用参数传递的就是实参的值，也是实参的别名，在函数体内做的操作都会影响到实参。

34. **左值引用和右值引用**

    左值引用是为了防止函数在传参和返回值时进行对象拷贝。右值引用是为了移动语义和完美转发。

    左值可以在等号左边，能够取地址的。

    右值只能在等号右边，不能取地址，不具有名字。

35. **友元函数**

    友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。

36. **extern C**

    是为了在c++中正确的调用c语言，加上以后会告诉编译器这块是c写的

37. **内联函数**

    调用函数时会有额外的开销，为了减少就会使用内联函数，被调用时直接将代码嵌入到调用他的地方去。有点类似于c里面的宏，但是要优于宏，它需要做类型检查，且有返回值

38. **4种强制类型转换**

    reinterpret_cast：必须是指针、引用、算术类型、函数指针或者成员指针

    const_cast：常量指针、引用被转化成非常量的指针、引用，并且仍然指向原来的对象

    static_cast：用于基类和派生类之z 间指针或者引用的转换；基本数据成员之间的转换等等

    dynamic_cast：有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

39. **函数指针**

    在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。

40. **模板**

    实现和所完成的功能基本相同，不同的仅仅是所涉及的数据类型不同，因此有了模板。、

41. **动态编译和静态编译**

    静态编译：编译器在编译文件时，将动态链接库链接到可执行文件中，使得在运行时不需要依赖动态链接库。

    动态编译：在编译时需要附带一个动态链接库

42. **使用智能指针管理内存,RAll是怎么回事**

    RAll也就是说在构造函数中申请资源，在析构函数中释放资源。最典型的代表就是C++里面的智能指针，动态的管理内存，再也不用担心忘记delete造成内存泄露的风险。

43. **迭代器++it和it++哪个好？**

    前者返回一个引用类型，后者返回一个对象。前者不会产生临时对象，后者会产生临时对象导致效率降低。

44. **左值引用和右值引用。**

    左值引用用于修改对象，能够取地址有名字。右值不能够取地址、没有名字，它主要是为了移动语义和完美转发。移动语义一般用在类的移动构造函数和移动赋值运算符。而完美转发是将参数传递到另一个函数时保留其原始的类型，这是通过模板和右值引用来实现的。

45. **STL的二级空间配置器**

    二级空间配置器是为了增加空间利用率，减少对空间的浪费。动态开辟内存时候要在堆上面申请，如果频繁的开辟释放内存则会产生很多外部碎片。设置二级空间配置器，在内存空间小于128比特时，就视为开辟小块内存，则调用二级空间配置器。

46. **NULL和nullptr**

    NULL当做整数0来看，如果我们想调用参数是指针的函数就可以用nullptr，它能够明确区分整型和指针类型，根据需要相应转换。

49. **vector和list区别**

    vector在内存中是连续存储的，对于访问元素效率非常高。但是在删除或者插入元素的时候需要移动大量元素保持元素连续性。

    list是基于双链表实现，每个元素都有一个指向前面的和后面的指针，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

50. **vector空间变化**

    vector有一个总空间大小和已用空间大小，如果两者相等了再添加新元素，则会引起空间动态增长。会重新分配内存，降低程序效率。当重新分配空间时，会分配原空间两倍的大小。vector也只会增加空间，就算ereas后面的元素，所占用内存依旧不变。所有空间只有在析构才会被系统回收。

51. **迭代器erase删除元素**

    删除顺序容器里面的，比如vecto、deque，会导致会使得删除元素之后的所有迭代器失效，它返回的是下一个有效地迭代器，所以用it = c.erase(it);

    而关联容器比如map、set、multimap等，erase只是被删除的迭代器失效，返回值是void，所以采用erase（it++）得方式删除迭代器。

52. **STL迭代器如何实现的？**

    迭代器是一种抽象的设计理念，他就是让你在不了解容器内部原理的情况下遍历容器，他提供了一个遍历容器内部得所有接口。

53. **map、set是怎么实现的，红黑树如何同时实现这两种容器，为什么要使用红黑树？**

    map、set底层实现的原理就是红黑树；定义一个模板参数，如果他是key他就是set，是map他就是map。使用红黑树能够高效的实现插入删除，而且时间复杂度低logn,又需要自动排序，红黑树能够满足要求。

54. **map的插入方式**

    c.insert(pair<int,string>(1,”student”));

    c.insert(map<int,string>::value_type(1,”student_one”));

    c.insert(make_pair(1,”student_one”));

    c[1] = “student_one”

55. **unordered_map(hash_map)和map的区别**

    unordered_map底层实现是hash_table是无序的,而map底层实现是红黑树是按照二叉搜索树存储。

56. **栈和队列区别**

    栈：先进后出，只能在表的一端删除一端插入，遍历的同时需要开辟空间，数据在栈底时会遍历整个栈

    队列：先进先出，在表的一段进另一端出，遍历时速度快，不用开辟空间。

57. **vector越界访问下表，map越界访问下标？vector删除元素时会不会释放空间？**

    vector越界访问下标会做边界检查，而map通过[]访问就是查找key值，如果没有，就添加进去。vector删除元素时不会释放空间，只有在析构时才会释放出来

58. **map中[]和find的区别**

    []会查找map里面的key对应的值，如果没有则添加进map。而find会用key查找，如果找到就返回该位置的迭代器，如果不存在就返回end迭代器。

59. **list和queue的区别**

    list是一种双向链表实现的容器，而queue是基于deque和list去实现的，专注于队列的操作。list支持对任意位置进行插入和删除，而queue支持队列的入会和出队以及对前端和末尾元素的访问。list更适合处理容器频繁的插入删除，而queue更适合任务调度和消息队列的场景。

61. **成员函数里面的memset(this,0,sizeof*this)会发生什么？**

    主要用于将整个对象的内存全部置为零，减少在构造函数中将他们初始化为0。但是在含有虚函数表的对象中会被破坏，后续对虚函数表的调用都将产生异常。还有类中含有C++类型的对象，会破化内部的内存。

    

    

# 操作系统

1. 进程死锁条件和解决方法

# 虚幻引擎

1. 看我用过虚幻引擎，问我常见的UE常见的纹理贴图有哪些（我说没有了解过。。）

# 面试提问

1. 你除了了解3D渲染方面的知识还了解其他游戏制作的知识吗？

2. 你的小游戏架构很完整，但是架构比较老，为什么会用这种架构呢？

3. 你认为游戏制作需要哪些方面的知识呢？渲染，建模，骨骼动画，实时碰撞，逻辑交互，UI，服务器编程，安全（反外挂）

4. 贴图中的马赛克如何解决

5. 进程和线程的关系

6. 已知两数之和，求一个数组中有没有两个数相加是这个数字。对空间复杂度和时间复杂度各有要求。

7. 用栈实现队列怎么实现 （一个用作入，一个用作出，当出栈中没有元素时，入栈中的元素才可以转换到出栈）

8. 用STL容器设计一个数据存储的数据结构，对存取时间复杂度有要求。（具体我忘记了，总之链表这些比较了解的话问题应该也不大）

9. 二叉树中序遍历非递归算法。

10. DX/GL的标准渲染管线（包括状态机设置，后期的模板测试等）

11. C++STL标准库 要求按顺序存取数据是O（1） 答案是deque（之前不了解这个deque，没答上来

12. deque的底层实现

13. 算法题：求完全二叉树的节点数；

14. 

    

